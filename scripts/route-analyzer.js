#!/usr/bin/env node

/**
 * Route and Flow Analyzer for Cliqstr
 * 
 * This script automatically analyzes and documents API routes and flow changes
 * in the Cliqstr application. It can be run manually or as part of a git hook.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Configuration
const API_ROUTES_DIR = path.join(process.cwd(), 'src', 'app', 'api');
const PAGE_ROUTES_DIR = path.join(process.cwd(), 'src', 'app');
const DOCS_OUTPUT_FILE = path.join(process.cwd(), 'docs', 'API-Routes-Flows.md');
const DOCS_TREE_FILE = path.join(process.cwd(), 'docs', 'RouteTree.md');
const EXCLUDED_DIRS = ['node_modules', '.next', '.git', 'public'];

// Helper function to get all route files
function findRouteFiles(dir, fileList = [], prefix = '') {
  if (EXCLUDED_DIRS.includes(path.basename(dir))) return fileList;
  
  const files = fs.readdirSync(dir);
  
  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stats = fs.statSync(filePath);
    
    if (stats.isDirectory()) {
      findRouteFiles(filePath, fileList, `${prefix}/${file}`);
    } else if (file === 'route.ts' || file === 'route.js') {
      fileList.push({
        path: filePath,
        route: prefix || '/',
        content: fs.readFileSync(filePath, 'utf8')
      });
    }
  });
  
  return fileList;
}

// Helper function to find page files
function findPageFiles(dir, fileList = [], prefix = '') {
  if (EXCLUDED_DIRS.includes(path.basename(dir))) return fileList;
  
  const files = fs.readdirSync(dir);
  
  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stats = fs.statSync(filePath);
    
    if (stats.isDirectory()) {
      findPageFiles(filePath, fileList, `${prefix}/${file}`);
    } else if (file === 'page.tsx' || file === 'page.js' || file === 'page.ts') {
      fileList.push({
        path: filePath,
        route: prefix || '/',
        content: fs.readFileSync(filePath, 'utf8')
      });
    }
  });
  
  return fileList;
}

// Extract HTTP methods from route files
function extractHttpMethods(content) {
  const methods = [];
  if (content.includes('export async function GET') || content.includes('export function GET')) methods.push('GET');
  if (content.includes('export async function POST') || content.includes('export function POST')) methods.push('POST');
  if (content.includes('export async function PUT') || content.includes('export function PUT')) methods.push('PUT');
  if (content.includes('export async function DELETE') || content.includes('export function DELETE')) methods.push('DELETE');
  if (content.includes('export async function PATCH') || content.includes('export function PATCH')) methods.push('PATCH');
  
  return methods.length ? methods : ['Unknown'];
}

// Extract route description from comments
function extractDescription(content) {
  const commentRegex = /\/\*\*([\s\S]*?)\*\//;
  const match = content.match(commentRegex);
  
  if (match && match[1]) {
    return match[1]
      .split('\n')
      .map(line => line.trim().replace(/^\*\s*/, ''))
      .filter(line => line)
      .join(' ');
  }
  
  // Try to find single-line comments
  const singleLineRegex = /\/\/\s*(.+)/;
  const singleLineMatch = content.match(singleLineRegex);
  
  if (singleLineMatch && singleLineMatch[1]) {
    return singleLineMatch[1].trim();
  }
  
  return 'No description available';
}

// Extract redirects from page files
function extractRedirects(content) {
  const redirects = [];
  const redirectRegex = /redirect\(['"]([^'"]+)['"]\)/g;
  let match;
  
  while ((match = redirectRegex.exec(content)) !== null) {
    redirects.push(match[1]);
  }
  
  return redirects;
}

// Generate documentation
function generateDocumentation() {
  console.log('Analyzing API routes and page flows...');
  
  const apiRoutes = findRouteFiles(API_ROUTES_DIR);
  const pageRoutes = findPageFiles(PAGE_ROUTES_DIR);
  
  let markdown = `# Cliqstr API Routes and Flow Documentation\n\n`;
  markdown += `*This file is automatically generated. Last updated: ${new Date().toISOString()}*\n\n`;
  
  // API Routes Section
  markdown += `## API Routes\n\n`;
  markdown += `| Route | Methods | Description |\n`;
  markdown += `| ----- | ------- | ----------- |\n`;
  
  apiRoutes.forEach(route => {
    const methods = extractHttpMethods(route.content);
    const description = extractDescription(route.content);
    
    markdown += `| \`${route.route}\` | ${methods.join(', ')} | ${description} |\n`;
  });
  
  // Page Flows Section
  markdown += `\n## Page Flows\n\n`;
  markdown += `| Page | Redirects To | Description |\n`;
  markdown += `| ---- | ------------ | ----------- |\n`;
  
  pageRoutes.forEach(page => {
    const redirects = extractRedirects(page.content);
    const description = extractDescription(page.content);
    
    markdown += `| \`${page.route}\` | ${redirects.length ? redirects.map(r => `\`${r}\``).join(', ') : 'None'} | ${description} |\n`;
  });
  
  // Add git changes section
  try {
    markdown += `\n## Recent Changes\n\n`;
    const recentChanges = execSync('git log -n 10 --pretty=format:"%h - %s (%cr)" -- src/app/').toString();
    markdown += "```\n" + recentChanges + "\n```\n";
  } catch (error) {
    markdown += `\n## Recent Changes\n\n*Git information not available*\n`;
  }
  
  // Write to file
  // Ensure docs directory exists
  try { fs.mkdirSync(path.dirname(DOCS_OUTPUT_FILE), { recursive: true }); } catch (_) {}
  fs.writeFileSync(DOCS_OUTPUT_FILE, markdown);
  console.log(`Documentation generated at ${DOCS_OUTPUT_FILE}`);
}

// -----------------------------
// Route Tree Generation Section
// -----------------------------

// Utility: determine if file should be shown in app/api trees
function isRouteRelevantFile(fileName) {
  return [
    'page.tsx', 'page.ts', 'page.js',
    'layout.tsx', 'layout.ts', 'layout.js',
    'route.ts', 'route.js',
    'loading.tsx', 'loading.ts', 'loading.js',
    'error.tsx', 'error.ts', 'error.js'
  ].includes(fileName);
}

// Utility: determine if file should be shown in components tree
function isComponentFile(fileName) {
  return /(\.(tsx|ts|jsx|js))$/i.test(fileName);
}

function buildTree(dir, options = {}) {
  const {
    base = dir,
    filter = () => true, // (entryPath, stats, name) => boolean
  } = options;

  const name = path.basename(dir);
  if (EXCLUDED_DIRS.includes(name)) return null;

  let children = [];
  let files;
  try {
    files = fs.readdirSync(dir, { withFileTypes: true });
  } catch (e) {
    return null;
  }

  for (const entry of files) {
    const entryPath = path.join(dir, entry.name);
    if (EXCLUDED_DIRS.includes(entry.name)) continue;

    // Respect filter
    if (!filter(entryPath, entry, entry.name)) continue;

    if (entry.isDirectory()) {
      const node = buildTree(entryPath, { base, filter });
      if (node) children.push(node);
    } else {
      children.push({
        name: entry.name,
        path: entryPath,
        type: 'file'
      });
    }
  }

  // Sort: folders first, then files alphabetically
  children.sort((a, b) => {
    const aDir = !!a.children;
    const bDir = !!b.children;
    if (aDir !== bDir) return aDir ? -1 : 1;
    return a.name.localeCompare(b.name);
  });

  return {
    name,
    path: dir,
    type: 'dir',
    children,
  };
}

function renderAsciiTree(node, prefix = '') {
  if (!node) return '';
  const lines = [];
  const isRoot = prefix === '';
  const label = isRoot ? node.name : node.name;
  if (isRoot) lines.push(label);
  const children = node.children || [];
  children.forEach((child, idx) => {
    const isLast = idx === children.length - 1;
    const connector = isLast ? '└── ' : '├── ';
    lines.push(prefix + connector + child.name);
    if (child.children) {
      const extension = isLast ? '    ' : '│   ';
      lines.push(renderAsciiTree(child, prefix + extension));
    }
  });
  return lines.join('\n');
}

function renderMarkdownTree(title, node) {
  const ascii = renderAsciiTree(node);
  return `## ${title}\n\n\`\n${ascii}\n\`\n`;
}

function generateRouteTrees() {
  console.log('Generating route trees for app, api, and components...');

  // Build trees with filters
  const appTree = buildTree(PAGE_ROUTES_DIR, {
    filter: (entryPath, entry, name) => {
      if (entry.isDirectory()) return true;
      return isRouteRelevantFile(name);
    },
  });

  const apiTree = buildTree(API_ROUTES_DIR, {
    filter: (entryPath, entry, name) => {
      if (entry.isDirectory()) return true;
      return isRouteRelevantFile(name);
    },
  });

  const componentsRoot = path.join(process.cwd(), 'src', 'components');
  const componentsTree = buildTree(componentsRoot, {
    filter: (entryPath, entry, name) => {
      if (entry.isDirectory()) return true;
      return isComponentFile(name);
    },
  });

  // Render markdown
  let md = `# Cliqstr Route & Components Tree\n\n`;
  md += `*This file is automatically generated. Last updated: ${new Date().toISOString()}*\n\n`;
  if (appTree) md += renderMarkdownTree('App Route Tree (src/app)', appTree) + '\n';
  if (apiTree) md += renderMarkdownTree('API Route Tree (src/app/api)', apiTree) + '\n';
  if (componentsTree) md += renderMarkdownTree('Components Tree (src/components)', componentsTree) + '\n';

  // Ensure docs directory exists and write
  try { fs.mkdirSync(path.dirname(DOCS_TREE_FILE), { recursive: true }); } catch (_) {}
  fs.writeFileSync(DOCS_TREE_FILE, md, 'utf8');
  console.log(`Route trees written to ${DOCS_TREE_FILE}`);

  // Also print concise ASCII trees to console for quick copy/share
  if (appTree) {
    console.log('\n=== App Route Tree (src/app) ===');
    console.log(renderAsciiTree(appTree));
  }
  if (apiTree) {
    console.log('\n=== API Route Tree (src/app/api) ===');
    console.log(renderAsciiTree(apiTree));
  }
  if (componentsTree) {
    console.log('\n=== Components Tree (src/components) ===');
    console.log(renderAsciiTree(componentsTree));
  }
}

// Main execution
generateDocumentation();
generateRouteTrees();
